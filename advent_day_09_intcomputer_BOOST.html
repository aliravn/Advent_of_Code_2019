<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
</head>
<body>
	<div id="outputPart1"></div>
	<div id="outputPart2"></div>

<script>
// Test 1.1	takes no input and produces a copy of itself as output.
// const program = [109,1,204,-1,1001,100,1,100,1008,100,16,101,1006,101,0,99];

// Test 1.2.should output a 16-digit number -> 1219070632396864
// const program = [1102,34915192,34915192,7,4,7,99,0];

// Test 1.3  should output the large number in the middle -> 1125899906842624
// const program = [104,1125899906842624,99];

// Puzzle input:
const program = [1102,34463338,34463338,63,1007,63,34463338,63,1005,63,53,1101,3,0,1000,109,988,209,12,9,1000,209,6,209,3,203,0,1008,1000,1,63,1005,63,65,1008,1000,2,63,1005,63,904,1008,1000,0,63,1005,63,58,4,25,104,0,99,4,0,104,0,99,4,17,104,0,99,0,0,1101,35,0,1007,1102,30,1,1013,1102,37,1,1017,1101,23,0,1006,1101,0,32,1008,1102,1,29,1000,1101,0,38,1010,1101,0,24,1002,1101,33,0,1003,1101,1,0,1021,1102,31,1,1019,1101,27,0,1014,1102,20,1,1005,1101,0,0,1020,1102,1,892,1027,1101,895,0,1026,1102,39,1,1015,1102,1,370,1029,1102,1,28,1001,1102,34,1,1012,1101,25,0,1016,1101,0,375,1028,1101,36,0,1018,1101,0,21,1004,1102,1,26,1009,1101,0,249,1022,1101,0,660,1025,1101,0,665,1024,1102,1,22,1011,1102,242,1,1023,109,5,2102,1,3,63,1008,63,31,63,1005,63,205,1001,64,1,64,1105,1,207,4,187,1002,64,2,64,109,8,21102,40,1,5,1008,1018,37,63,1005,63,227,1105,1,233,4,213,1001,64,1,64,1002,64,2,64,109,7,2105,1,3,1001,64,1,64,1106,0,251,4,239,1002,64,2,64,109,-7,1201,-7,0,63,1008,63,20,63,1005,63,271,1106,0,277,4,257,1001,64,1,64,1002,64,2,64,109,-10,1208,0,33,63,1005,63,295,4,283,1106,0,299,1001,64,1,64,1002,64,2,64,109,-6,1207,4,27,63,1005,63,319,1001,64,1,64,1105,1,321,4,305,1002,64,2,64,109,12,1207,-1,33,63,1005,63,339,4,327,1105,1,343,1001,64,1,64,1002,64,2,64,109,6,1206,6,355,1106,0,361,4,349,1001,64,1,64,1002,64,2,64,109,21,2106,0,-8,4,367,1106,0,379,1001,64,1,64,1002,64,2,64,109,-29,1202,0,1,63,1008,63,36,63,1005,63,403,1001,64,1,64,1105,1,405,4,385,1002,64,2,64,109,11,21107,41,40,-6,1005,1012,421,1105,1,427,4,411,1001,64,1,64,1002,64,2,64,109,-11,2101,0,-4,63,1008,63,33,63,1005,63,453,4,433,1001,64,1,64,1106,0,453,1002,64,2,64,109,-7,21108,42,40,10,1005,1010,469,1105,1,475,4,459,1001,64,1,64,1002,64,2,64,109,1,1201,4,0,63,1008,63,20,63,1005,63,497,4,481,1105,1,501,1001,64,1,64,1002,64,2,64,109,5,21107,43,44,5,1005,1011,523,4,507,1001,64,1,64,1106,0,523,1002,64,2,64,109,20,21108,44,44,-7,1005,1019,541,4,529,1106,0,545,1001,64,1,64,1002,64,2,64,109,2,1205,-8,561,1001,64,1,64,1106,0,563,4,551,1002,64,2,64,109,-23,2108,22,0,63,1005,63,583,1001,64,1,64,1105,1,585,4,569,1002,64,2,64,109,-6,2107,30,1,63,1005,63,605,1001,64,1,64,1105,1,607,4,591,1002,64,2,64,109,23,1205,-1,621,4,613,1105,1,625,1001,64,1,64,1002,64,2,64,109,-19,2102,1,-3,63,1008,63,29,63,1005,63,647,4,631,1106,0,651,1001,64,1,64,1002,64,2,64,109,28,2105,1,-7,4,657,1106,0,669,1001,64,1,64,1002,64,2,64,109,-17,1206,6,687,4,675,1001,64,1,64,1105,1,687,1002,64,2,64,109,2,21101,45,0,1,1008,1017,42,63,1005,63,707,1106,0,713,4,693,1001,64,1,64,1002,64,2,64,109,-6,2101,0,-3,63,1008,63,34,63,1005,63,733,1105,1,739,4,719,1001,64,1,64,1002,64,2,64,109,3,21101,46,0,1,1008,1014,46,63,1005,63,761,4,745,1106,0,765,1001,64,1,64,1002,64,2,64,109,5,21102,47,1,-7,1008,1011,47,63,1005,63,787,4,771,1105,1,791,1001,64,1,64,1002,64,2,64,109,-24,2108,24,8,63,1005,63,813,4,797,1001,64,1,64,1106,0,813,1002,64,2,64,109,5,1208,10,29,63,1005,63,829,1105,1,835,4,819,1001,64,1,64,1002,64,2,64,109,7,2107,23,-4,63,1005,63,853,4,841,1105,1,857,1001,64,1,64,1002,64,2,64,109,-2,1202,0,1,63,1008,63,21,63,1005,63,879,4,863,1105,1,883,1001,64,1,64,1002,64,2,64,109,15,2106,0,8,1106,0,901,4,889,1001,64,1,64,4,64,99,21102,1,27,1,21102,915,1,0,1105,1,922,21201,1,51839,1,204,1,99,109,3,1207,-2,3,63,1005,63,964,21201,-2,-1,1,21101,942,0,0,1106,0,922,21201,1,0,-1,21201,-2,-3,1,21101,957,0,0,1105,1,922,22201,1,-1,-2,1105,1,968,21201,-2,0,-2,109,-3,2106,0,0];
intComputer = (i, input, output, relativeBase) => {
	while (opcode !== 99) {
		// define the opcode in the first position of new set of instructions
		// mode1 = position (parameter = position)
		// mode2 = immediate (parameter = value)
		// mode3 = relative (parameter + relativeBase = position)
		// opcode is either 1/2/3/4 or 99, does not make sense to have 2-digit opcode for 01/02.. etc
		// reverse the input containing opcode, find parameters for pos/val parameters for instructions
		let mode1 = 0, mode2 = 0, mode3 = 0;
		let param1 = Number(input[i + 1]),
			param2 = Number(input[i + 2]),
			param3 = Number(input[i + 3]);
		let val1 = 0, val2 = 0, val3 = 0;

		if (input[i].toString().length <= 2) {
			opcode = input[i];
		} else if (input[i].toString().length > 2) {
			opcode = Number(input[i].toString().slice(-1));
			const reverseArray = reverseString(input[i].toString());

			// 1st param is valid for any opcode
			mode1 = Number(reverseArray[2]);
			// 2nd param may be present for opcode 1 or 2, if not == zero
			if (reverseArray[3] !== undefined) {
				mode2 = Number(reverseArray[3]);
			} else {
				mode2 = 0;
			}
			// 3rd param may be present for opcode 1 or 2, if not == zero
			if (reverseArray[4] !== undefined) {
				mode3 = Number(reverseArray[4]);
			} else {
				mode3 = 0;
			}
		}
		// console.log(opcode);

		if (opcode === 99) {
			console.log(output);
			console.log('stop');
			break;
		}

		// opcode = 3 gets input and stores it at specified location
		// location to store assigned as next number after opcode with position mode or +relBase with relative mode
		// action: take whatever is stored in position param1 + relativeBase as input
		if (opcode === 3) {
			let inputValueLocation;
			if (mode1 === 0) {
				inputValueLocation = param1;
			} else if ( mode1 === 2) {
				inputValueLocation = param1 + relativeBase;
			}
			input[inputValueLocation] = 1;
			i += 2; // move onto next set of instructions
			continue;
		}

		if (opcode === 4) { // opcode = 4 outputs whatever is at the specified location
			if (mode1 === 0) {
				output.push(input[param1]);
			} else if (mode1 === 1) {
				output.push(param1);
			} else {
				output.push(input[param1 + relativeBase]);
			}
			i += 2; // move onto next set of instructions

			continue;
		}

		if (opcode === 9) { // opcode = 9 adjusts the relative base by the value of its only parameter.
			if (mode1 === 0) {
				if (input[param1] !== undefined) {
					relativeBase = relativeBase + input[param1];
				} else {
					relativeBase = relativeBase + 0;
				}
			} else if (mode1 === 1) {
				relativeBase = relativeBase + param1;
			} else {
				if (input[param1 + relativeBase] !== undefined) {
					relativeBase = relativeBase + input[param1 + relativeBase];
				}
			}
			i += 2; // move onto next set of instructions
			continue;
		}

		if (opcode === 1 || opcode === 2 || opcode >= 5) {
			if (mode1 === 0 && input[param1] !== undefined) {
				val1 = input[param1];
			} else if (mode1 === 1) {
				val1 = param1;
			} else if (mode1 === 2 && input[param1 + relativeBase] !== undefined){
				val1 = input[param1 + relativeBase];
			} else {
				val1 = 0;
			}

			if (mode2 === 0 && input[param2] !== undefined) {
				val2 = input[param2];
			} else if (mode2 === 1) {
				val2 = param2;
			} else if (mode2 === 2 && input[param2 + relativeBase] !== undefined) {
				val2 = input[param2 + relativeBase];
			} else {
				val2 = 0;
			}

			if (mode3 === 0) {
				if (input[param3] !== undefined) {
					val3 = input[param3];
				} else {
					val3 = 0;
				}
			} else if (mode3 === 1) {
				val3 = param3;
			} else {
				if (input[param3 + relativeBase] !== undefined) {
					val3 = input[param3 + relativeBase];
				} else {
					val3 = 0;
				}
				param3 = param3 + relativeBase;
			}

			//if the first parameter is equal to the second parameter, it stores 1 in the position given by the third parameter.
			// Otherwise, it stores 0}
			if (opcode === 8) {
				if (val1 === val2) {
					input[param3] = 1;
				} else {
					input[param3] = 0;
				}
				i += 4; // move onto next set of instructions
			}
			// if (opcode === 7) {if the first parameter is less than the second parameter,
			// it stores 1 in the position given by the third parameter.
			// Otherwise, it stores 0}
			if (opcode === 7) {
				if (val1 < val2) {
					input[param3] = 1;
				} else {
					input[param3] = 0;
				}
				i += 4; // move onto next set of instructions
			}

			if (opcode === 1) {
				input[param3] = val1 + val2; // saves result of opcode actions to specified location
				i += 4; // move onto next set of instructions
			}

			if (opcode === 2) {
				input[param3] = val1 * val2; // saves result of opcode actions to specified location
				i += 4; // move onto next set of instructions
			}

			// if the first parameter is non-zero, it sets the instruction pointer to the value from the second parameter.
			// Otherwise, it does nothing
			if (opcode === 5) {
				if (val1 !== 0) {
					i = val2;
				} else {
					i += 3; // move onto next set of instructions
				}
			}

			// if the first parameter is zero, it sets the instruction pointer to the value from the second parameter.
			// Otherwise, it does nothing
			if (opcode === 6) {
				if (val1 === 0) {
					i = val2;
				} else {
					i += 3; // move onto next set of instructions
				}
			}
		}
	}
}

const reverseString = str => str.split("").reverse();


let opcode;
let output = [];
let relativeBase = 0;
let i = 0;
const result = intComputer(i, program, output, relativeBase);


</script>
</body>

</html>
